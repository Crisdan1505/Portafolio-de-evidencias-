<!DOCTYPE html> 
<html lang="es"> 
<head>
<style> 
/* ==================== RESET BÁSICO Y TIPOGRAFÍA ==================== */ 
@import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap');

* { 
    margin: 0; 
    padding: 0; 
    box-sizing: border-box; 
} 
 
body { 
    font-family: 'Poppins', sans-serif; 
    line-height: 1.6; 
    background-color: #f4f4f4; /* Gris claro */
    color: #333; /* Gris oscuro para mejor contraste */
    padding: 10px; 
} 
 
.container { 
    max-width: 1200px; 
    margin: 0 auto; 
    border: 2px solid #ccc; 
    padding: 20px; 
    background-color: white; /* Fondo blanco dentro del contenedor */
    border-radius: 8px; /* Bordes redondeados opcionales */
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); /* Sombra ligera */
}
/* ==================== ENCABEZADOS ==================== */ 
h1 { 
    font-size: 32px; 
    margin-bottom: 20px; 
    color: #2c3e50; /* Azul oscuro elegante */
    text-align: center; 
    font-weight: 600;
} 
 
h2 { 
    font-size: 24px; 
    margin-bottom: 15px; 
    color: #34495e; 
    font-weight: 500;
} 
 
h3 { 
    font-size: 20px; 
    margin-bottom: 10px; 
    color: #555; 
    font-weight: 500;
} 
 
p { 
    font-size: 16px; 
    margin: 10px 0; 
    text-align: justify; 
    color: #333;
    line-height: 1.6;
}
.controls { 
    border: 2px solid black; 
    padding: 20px; 
    margin-bottom: 20px; 
} 

.input-group { 
    margin-bottom: 20px; 
} 

.input-group label { 
    display: block; 
    font-weight: bold; 
    margin-bottom: 5px; 
    color: black; 
} 

.input-group input { 
    width: 300px; 
    padding: 8px; 
    border: 2px solid black; 
    font-size: 14px; 
    margin-bottom: 10px; 
} 

.input-group input:focus { 
    outline: none; 
    border-color: blue; 
}

/* ==================== BOTONES ==================== */ 
button { 
    padding: 12px 24px; 
    font-size: 15px; 
    font-family: 'Poppins', sans-serif;
    font-weight: 600; 
    border: none; 
    border-radius: 8px; 
    background-color: #8e44ad; /* Morado principal */
    color: white; 
    cursor: pointer; 
    margin-right: 10px; 
    margin-bottom: 10px; 
    transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
} 
 
button:hover { 
    background-color: #732d91; /* Morado más oscuro */
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0,0,0,0.15);
} 

button:active {
    transform: translateY(0);
    background-color: #5e2474;
    box-shadow: 0 3px 6px rgba(0,0,0,0.1);
}

/* ==================== NÚMEROS PREDEFINIDOS ==================== */ 
.preset-section { 
    margin-top: 20px; 
} 
 
.preset-section h3 { 
    font-size: 16px; 
    margin-bottom: 10px; 
    color: black; 
} 
 
.preset-section p { 
    margin-bottom: 15px; 
    color: black; 
    font-size: 14px; 
    text-align: left; 
} 
 
.preset-numbers { 
    display: flex; 

flex-wrap: wrap; 
gap: 5px; 
margin-top: 15px; 
} 
.preset-btn { 
padding: 5px 10px; 
border: 2px solid black; 
background-color: white; 
cursor: pointer; 
font-size: 12px; 
font-weight: bold; 
} 
.preset-btn:hover { 
background-color: black; 
color: white; 
} 

/* ==================== RECTA NUMÉRICA ==================== */ 
.number-line-container { 
    border: 2px solid black; 
    padding: 20px; 
    margin-bottom: 20px; 
} 
 
.number-line-container h2 { 
    font-size: 18px; 
    margin-bottom: 15px; 
    text-align: center; 
    color: black; 
} 
 
.number-line { 
    width: 100%; 
    height: 100px; 
    position: relative; 
    background-color: white; 
    border: 1px solid black; 
    margin: 20px 0; 
} 
 
.range-info { 
    text-align: center; 
    margin-top: 10px; 
} 
 
.range-info small { 
    color: black; 
    font-size: 12px; 
} 
/* ==================== ELEMENTOS DE LA RECTA - Estilo Moderno ==================== */

.line {
    position: absolute;
    top: 50px;
    left: 5%;
    right: 5%;
    height: 6px;
    background: linear-gradient(90deg, #4a90e2, #50e3c2);
    border-radius: 3px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

.tick {
    position: absolute;
    width: 3px;
    height: 24px;
    background-color: #4a90e2;
    top: 42px;
    border-radius: 1px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15);
}

.tick-label {
    position: absolute;
    top: 70px;
    font-size: 13px;
    font-weight: 600;
    color: #333;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    transform: translateX(-50%);
    user-select: none;
    text-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);
}

/* ==================== PUNTOS EN LA RECTA - Estilo Moderno ==================== */

.number-point {
    position: absolute;
    width: 18px;
    height: 18px;
    top: 40px;
    transform: translateX(-50%);
    border: 2.5px solid #333;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.number-point:hover {
    transform: translateX(-50%) scale(1.2);
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

.number-point.naturals {
    background-color: #e74c3c; /* rojo vibrante */
}

.number-point.integers {
    background-color: #3498db; /* azul moderno */
}

.number-point.rationals {
    background-color: #27ae60; /* verde fresco */
}

.number-point.irrationals {
    background-color: #f1c40f; /* amarillo dorado */
}

.point-label {
    position: absolute;
    top: -30px;
    transform: translateX(-50%);
    background-color: #fff;
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 3px 6px;
    font-size: 11px;
    font-weight: 600;
    white-space: nowrap;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    pointer-events: none;
    user-select: none;
}

/* =================== PANELES DE INFORMACIÓN - Estilo Verde Azulado =================== */

.info-panels {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 24px;
    padding: 10px;
}

.classification-panel,
.points-panel,
.distance-calculator {
    background-color: #fff;
    border: 1.8px solid #3ba99c;  /* verde azulado */
    border-radius: 10px;
    padding: 20px 25px;
    box-shadow: 0 4px 10px rgba(59, 169, 156, 0.15);
    transition: box-shadow 0.3s ease;
}

.classification-panel:hover,
.points-panel:hover,
.distance-calculator:hover {
    box-shadow: 0 8px 20px rgba(59, 169, 156, 0.3);
}

.classification-panel h3,
.points-panel h3,
.distance-calculator h3 {
    font-size: 18px;
    margin-bottom: 18px;
    color: #2a6f68; /* tono más oscuro del verde azulado */
    border-bottom: 3px solid #3ba99c;
    padding-bottom: 6px;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    font-weight: 700;
}

/* ================== LEYENDA DE CLASIFICACIÓN - Estilo Moderno ================== */

.classification-legend {
    margin-bottom: 25px;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 12px;
    margin: 12px 0;
    padding: 6px 8px;
    border-radius: 8px;
    background-color: #f7f9fa;
    box-shadow: 0 1px 4px rgba(0,0,0,0.05);
    transition: background-color 0.3s ease;
}

.legend-item:hover {
    background-color: #e1f0f7;
}

.legend-color {
    width: 22px;
    height: 22px;
    border-radius: 5px;
    border: 2px solid #444;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.legend-color.naturals {
    background-color: #e74c3c; /* rojo suave */
}

.legend-color.integers {
    background-color: #3498db; /* azul moderno */
}

.legend-color.rationals {
    background-color: #27ae60; /* verde fresco */
}

.legend-color.irrationals {
    background-color: #f1c40f; /* amarillo dorado */
}

.classification-info h4 {
    font-size: 15px;
    margin: 18px 0 12px 0;
    color: #222;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    font-weight: 600;
}

.classification-info ul {
    margin-left: 22px;
    list-style-type: disc;
}

.classification-info li {
    margin: 6px 0;
    font-size: 13px;
    color: #555;
}
 
/* ==================== LISTA DE PUNTOS - Estilo Moderno ==================== */

.points-list {
    min-height: 200px;
    background-color: #fafafa;
    border-radius: 10px;
    padding: 15px 20px;
    box-shadow: inset 0 0 8px rgba(0,0,0,0.05);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.empty-state p {
    font-size: 15px;
    color: #666;
    text-align: center;
    margin: 30px 0 10px 0;
    font-style: italic;
}

.empty-state small {
    display: block;
    text-align: center;
    font-size: 13px;
    color: #999;
}

.point-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 15px;
    margin: 7px 0;
    border: 1.5px solid #ccc;
    border-radius: 8px;
    background-color: #fff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.07);
    transition: background-color 0.3s ease, border-color 0.3s ease;
}

.point-item:hover {
    background-color: #e8f0fe;
    border-color: #5a9bf6;
}

/* ================== CALCULADORA DE DISTANCIAS - Estilo Naranja Cálido ================== */

.calculator-description {
    margin-bottom: 18px;
    font-size: 14px;
    color: #5a3e1b;
    text-align: left;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.distance-inputs {
    margin-bottom: 22px;
}

.distance-field {
    margin-bottom: 18px;
}

.distance-field label {
    display: block;
    font-weight: 600;
    margin-bottom: 6px;
    color: #7a532c;
}

.custom-select {
    position: relative;
    width: 100%;
}

.select-selected {
    padding: 10px 35px 10px 12px;
    border: 1.8px solid #d2691e;
    background-color: #fff8f0;
    cursor: pointer;
    font-size: 15px;
    border-radius: 8px;
    position: relative;
    user-select: none;
    transition: border-color 0.3s ease;
}

.select-selected:after {
    content: "▼";
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 12px;
    color: #d2691e;
    pointer-events: none;
}

.select-selected:hover,
.select-selected.active {
    border-color: #ff7f50;
    box-shadow: 0 0 8px rgba(255, 127, 80, 0.4);
}

.select-items {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background-color: #fff8f0;
    border: 1.8px solid #d2691e;
    border-top: none;
    z-index: 1000;
    max-height: 160px;
    overflow-y: auto;
    border-radius: 0 0 8px 8px;
    display: none;
    box-shadow: 0 4px 12px rgba(210, 105, 30, 0.15);
}

.select-items.show {
    display: block;
}

.select-items div {
    padding: 10px 12px;
    cursor: pointer;
    border-bottom: 1px solid #f0d6bf;
    font-size: 14px;
    color: #7a532c;
    transition: background-color 0.25s ease;
}

.select-items div:hover {
    background-color: #ff7f50;
    color: #fff;
}

.distance-btn {
    width: 100%;
    padding: 14px;
    background-color: #ff7f50;
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
}

/* ==================== RESPONSIVE ==================== */ 
 @media (max-width: 768px) { 
    .container { 
        margin: 5px; 
    } 
     
    .input-group input { 
        width: 100%; 
max-width: 300px; 
} 
.info-panels { 
grid-template-columns: 1fr; 
} 
} 

</style>
</head>

<body> 
<div class="container"> 
<h1>Visualizador de la Recta Numérica</h1> 
<p>Tecnológico de Software • Fundamentos de Álgebra • 1° 
Cuatrimestre 2025</p>
 <section class="controls"> 
<h2>Controles de Entrada</h2> 
<div class="input-group"> 
<label for="numberInput">Valor del número:</label> 
<input type="text" id="numberInput"  
placeholder="Ej: sqrt(7), 2*π, √2, 1/3"> 
<button type="button" onclick="addNumber()"> 
Agregar Número 
</button> 
<button type="button" onclick="clearAll()"> 
Limpiar Todo 
</button> 
</div> <div class="preset-section"> 
    <h3>Números Predefinidos</h3> 
    <p>Haz clic en cualquier número para agregarlo automáticamente:</p> 
     
    <div class="preset-numbers"> 
        <span class="preset-btn" onclick="addPresetNumber('π')">π</span> 
        <span class="preset-btn" onclick="addPresetNumber('e')">e</span> 
        <span class="preset-btn" onclick="addPresetNumber('√2')">√2</span> 
        <span class="preset-btn" onclick="addPresetNumber('√3')">√3</span> 
        <span class="preset-btn" onclick="addPresetNumber('φ')">φ</span> 
        <span class="preset-btn" 
onclick="addPresetNumber('1/3')">1/3</span> 
        <span class="preset-btn" 
onclick="addPresetNumber('-1/2')">-1/2</span> 
        <span class="preset-btn" 
onclick="addPresetNumber('2.5')">2.5</span> 
        <span class="preset-btn" 
onclick="addPresetNumber('-√2')">-√2</span> 
        <span class="preset-btn" 
onclick="addPresetNumber('2*π')">2*π</span> 
    </div> 

</div>  
</section>

<section class="number-line-container"> 
<h2>Recta Numérica Interactiva</h2> 
<div class="number-line" id="numberLine"> 
<!-- Los elementos de la recta se generan dinámicamente con 
JavaScript --> 
</div> 
<p class="range-info"> 
<small>Rango de visualización: -10 a +10 (números fuera de 
este rango no se mostrarán)</small> 
</p> 
</section> 
 
<section class="info-panels"> 
    <!-- Panel de clasificación de conjuntos numéricos --> 
    <div class="classification-panel"> 
        <h3>Clasificación de Conjuntos Numéricos</h3> 
        <div class="classification-legend"> 
            <div class="legend-item"> 
                <div class="legend-color naturals"></div> 
                <span><strong>ℕ - Naturales:</strong> {1, 2, 3, 4, 
...}</span> 
            </div> 
            <div class="legend-item"> 
                <div class="legend-color integers"></div> 
                <span><strong>ℤ - Enteros:</strong> {..., -2, -1, 0, 
1, 2, ...}</span> 
            </div> 
            <div class="legend-item"> 
                <div class="legend-color rationals"></div> 
                <span><strong>ℚ - Racionales:</strong> Fracciones y 
decimales finitos/periódicos</span> 
            </div> 
            <div class="legend-item"> 
                <div class="legend-color irrationals"></div> 
                <span><strong>ℝ-ℚ - Irracionales:</strong> π, e, √2, 
decimales infinitos no periódicos</span> 
            </div> 
        </div> 
         
        <div class="classification-info"> 
            <h4>Propiedades importantes:</h4> 
            <ul> 
                <li><strong>ℕ ⊂ ℤ:</strong> Todo número natural es 
entero</li> 
                <li><strong>ℤ ⊂ ℚ:</strong> Todo entero puede 
escribirse como fracción</li>
 <li><strong>ℚ ∪ (ℝ-ℚ) = ℝ:</strong> Los reales son 
la unión de racionales e irracionales</li> 
                <li><strong>ℚ ∩ (ℝ-ℚ) = ∅:</strong> No existen 
números que sean ambos</li> 
            </ul> 
        </div> 
    </div> 

 <!-- Panel de lista de puntos --> 
    <div class="points-panel"> 
        <h3>Puntos en la Recta</h3> 
        <div id="pointsList"> 
            <div class="empty-state"> 
                <p>Agrega números para ver su clasificación 
automática aquí</p> 
                <small>Los puntos aparecerán ordenados de menor a 
mayor</small> 
            </div> 
        </div> 
    </div> 

 <!-- Panel calculadora de distancias --> 
    <div class="distance-calculator"> 
        <h3>Calculadora de Distancias</h3> 
        <p class="calculator-description"> 
            Selecciona dos puntos para calcular la distancia entre 
ellos en la recta numérica. 
        </p> 
         
        <div class="distance-inputs"> 
            <div class="distance-field"> 
 <label>Punto A:</label> 
                <div class="custom-select" id="pointA-container"> 
                    <div class="select-selected" 
id="pointA-selected">Selecciona un punto</div> 
                    <div class="select-items" id="pointA-items"> 
                        <div data-value="">Selecciona un punto</div> 
                    </div> 
                </div> 
            </div> 
 
            <div class="distance-field"> 
                <label>Punto B:</label> 
                <div class="custom-select" id="pointB-container"> 
                    <div class="select-selected" 
id="pointB-selected">Selecciona un punto</div> 
                    <div class="select-items" id="pointB-items"> 
                        <div data-value="">Selecciona un punto</div> 
                    </div> 
                </div> 
            </div> 
        </div> 
 
        <button type="button" class="distance-btn" 
onclick="calculateDistance()"> 
            Calcular Distancia 
        </button> 
         
        <div id="distanceResult"> 
            <div class="distance-placeholder"> 
                <div><strong>Calculadora de Distancias</strong></div> 
                <div>Los resultados aparecerán aquí</div> 
            </div> 
        </div> 
    </div> 
</section> 


</div> 
<script>
/**
 * VISUALIZADOR DE LA RECTA NUMÉRICA - JavaScript Corregido
 * Autor: M. en C. Jorge J. Pedrozo Romero
 * Tecnológico de Software - Fundamentos de Álgebra
 * 1° Cuatrimestre 2025
 * 
 * Este archivo contiene toda la lógica para:
 * - Parsing de expresiones matemáticas
 * - Clasificación de números reales
 * - Visualización en la recta numérica
 * - Cálculo de distancias entre puntos
 */

// ========== VARIABLES GLOBALES ==========
let points = [];
let currentRange = 10;

// ========== CONSTANTES MATEMÁTICAS ==========
const CONSTANTS = {
    // Constantes básicas
    'π': Math.PI,
    'pi': Math.PI,
    'e': Math.E,
    
    // Número áureo (phi)
    'φ': (1 + Math.sqrt(5)) / 2,
    'phi': (1 + Math.sqrt(5)) / 2,
    
    // Tau (2π)
    'τ': 2 * Math.PI,
    'tau': 2 * Math.PI,
    
    // Logaritmos naturales
    'ln2': Math.LN2,
    'ln10': Math.LN10,
    
    // Raíces cuadradas comunes
    '√2': Math.sqrt(2),
    '√3': Math.sqrt(3),
    '√5': Math.sqrt(5),
    '√7': Math.sqrt(7),
    '√8': Math.sqrt(8),
    '√10': Math.sqrt(10),
    '√11': Math.sqrt(11),
    '√12': Math.sqrt(12),
    '√13': Math.sqrt(13),
    '√15': Math.sqrt(15),
    '√17': Math.sqrt(17),
    '√19': Math.sqrt(19),
    '√20': Math.sqrt(20),
    
    // Raíces cuadradas negativas
    '-√2': -Math.sqrt(2),
    '-√3': -Math.sqrt(3),
    '-√5': -Math.sqrt(5)
};

// ========== FUNCIONES DE PARSING DE NÚMEROS ==========

/**
 * Función principal para convertir texto en número
 * Maneja constantes, fracciones, raíces y expresiones básicas
 * @param {string} input - La expresión matemática ingresada
 * @returns {number|null} - El valor numérico o null si es inválida
 */
function parseNumber(input) {
    // Limpiar el input de espacios en blanco
    input = input.trim().replace(/\s+/g, '');

    // Verificar si es una constante matemática directa
    if (CONSTANTS.hasOwnProperty(input)) {
        return CONSTANTS[input];
    }

    // Reemplazar constantes matemáticas en la expresión
    let processedInput = input;
    for (const [symbol, value] of Object.entries(CONSTANTS)) {
        // Crear expresión regular para reemplazar el símbolo
        const regex = new RegExp(symbol.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
        processedInput = processedInput.replace(regex, value.toString());
    }

    // Manejar fracciones simples (sin otros operadores)
    if (input.includes('/') && !input.includes('*') && !input.includes('+') && !input.includes('-', 1)) {
        const parts = input.split('/');
        if (parts.length === 2) {
            const numerator = parseFloat(parts[0]);
            const denominator = parseFloat(parts[1]);
            
            // Verificar que ambos son números válidos y denominador no es cero
            if (!isNaN(numerator) && !isNaN(denominator) && denominator !== 0) {
                return numerator / denominator;
            }
        }
    }

    // Manejar raíces cuadradas básicas con símbolo √ (sin otros operadores)
    if (input.startsWith('√') && !input.includes('*') && !input.includes('+') && !input.includes('-', 1)) {
        const radicand = parseFloat(input.slice(1));
        if (!isNaN(radicand) && radicand >= 0) {
            return Math.sqrt(radicand);
        }
    }

    // Manejar raíces cuadradas negativas
    if (input.startsWith('-√') && !input.includes('*') && !input.includes('+')) {
        const radicand = parseFloat(input.slice(2));
        if (!isNaN(radicand) && radicand >= 0) {
            return -Math.sqrt(radicand);
        }
    }

    // Manejar función sqrt() con cualquier expresión dentro
    if (input.includes('sqrt(')) {
        // Patrón para encontrar sqrt(cualquier expresión)
        const sqrtPattern = /sqrt\(([^)]+)\)/g;
        let processedInputSqrt = input;
        let match;
        
        // Procesar todas las ocurrencias de sqrt()
        while ((match = sqrtPattern.exec(input)) !== null) {
            const innerExpression = match[1];
            let innerValue;
            
            // Evaluar la expresión dentro del sqrt()
            try {
                // Para fracciones simples dentro de sqrt()
                if (innerExpression.includes('/') && !innerExpression.includes('*') && 
                    !innerExpression.includes('+') && !innerExpression.includes('-', 1)) {
                    const parts = innerExpression.split('/');
                    if (parts.length === 2) {
                        const num = parseFloat(parts[0]);
                        const den = parseFloat(parts[1]);
                        if (!isNaN(num) && !isNaN(den) && den !== 0) {
                            innerValue = num / den;
                        }
                    }
                } else {
                    // Para otras expresiones, evaluar directamente
                    const safeChars = /^[0-9+\-*/.() ]+$/;
                    if (safeChars.test(innerExpression)) {
                        innerValue = Function('"use strict"; return (' + innerExpression + ')')();
                    } else {
                        innerValue = parseFloat(innerExpression);
                    }
                }
                
                // Si el valor interno es válido, calcular su raíz cuadrada
                if (!isNaN(innerValue) && innerValue >= 0) {
                    const sqrtValue = Math.sqrt(innerValue);
                    processedInputSqrt = processedInputSqrt.replace(match[0], sqrtValue.toString());
                }
            } catch (e) {
                // Si falla la evaluación, continuar con el siguiente
                continue;
            }
        }
        
        // Si la entrada era solo una raíz simple, devolver el resultado directamente
        if (/^sqrt\([^)]+\)$/.test(input)) {
            const innerExpression = input.match(/sqrt\(([^)]+)\)/)[1];
            let innerValue;
            
            try {
                // Para fracciones dentro de sqrt()
                if (innerExpression.includes('/') && !innerExpression.includes('*') && 
                    !innerExpression.includes('+') && !innerExpression.includes('-', 1)) {
                    const parts = innerExpression.split('/');
                    if (parts.length === 2) {
                        const num = parseFloat(parts[0]);
                        const den = parseFloat(parts[1]);
                        if (!isNaN(num) && !isNaN(den) && den !== 0) {
                            innerValue = num / den;
                        }
                    }
                } else {
                    // Para expresiones o números simples
                    const safeChars = /^[0-9+\-*/.() ]+$/;
                    if (safeChars.test(innerExpression)) {
                        innerValue = Function('"use strict"; return (' + innerExpression + ')')();
                    } else {
                        innerValue = parseFloat(innerExpression);
                    }
                }
                
                // Retornar la raíz cuadrada si es válida
                if (!isNaN(innerValue) && innerValue >= 0) {
                    return Math.sqrt(innerValue);
                }
            } catch (e) {
                // Si falla la evaluación, continuar con el flujo normal
            }
        }
        
        // Si había múltiples sqrt() o expresiones complejas, usar el input procesado
        input = processedInputSqrt;
    }

    // Evaluar expresiones matemáticas más complejas
    try {
        // Reemplazar operadores por equivalentes de JavaScript
        processedInput = processedInput.replace(/\^/g, '**'); // Potencias

        // Verificar que solo contiene caracteres seguros para evaluar
        const safeChars = /^[0-9+\-*/.() ]+$/;
        if (safeChars.test(processedInput)) {
            const result = Function('"use strict"; return (' + processedInput + ')')();
            if (typeof result === 'number' && !isNaN(result) && isFinite(result)) {
                return result;
            }
        }
    } catch (e) {
        // Si falla la evaluación, continuar con el parsing normal
    }

    // Intentar parsear como número decimal normal
    const num = parseFloat(processedInput);
    if (!isNaN(num)) {
        return num;
    }

    // Si nada funcionó, retornar null
    return null;
}

// ========== FUNCIONES DE NORMALIZACIÓN Y CLASIFICACIÓN ==========

/**
 * Normaliza una expresión matemática para facilitar el análisis
 * @param {string} expr - La expresión a normalizar
 * @returns {string} - La expresión normalizada
 */
function normalizeExpression(expr) {
    return expr.replace(/\s/g, '')          // Remover espacios
              .replace(/\*\*/g, '^')        // Convertir ** a ^
              .toLowerCase();               // Convertir a minúsculas para pi, e, etc.
}

/**
 * Clasifica expresiones matemáticas complejas
 * @param {string} expression - La expresión matemática original
 * @param {number} result - El resultado numérico de la expresión
 * @returns {string} - El tipo de número ('naturals', 'integers', 'rationals', 'irrationals')
 */
function classifyExpression(expression, result) {
    const normalizedExpr = normalizeExpression(expression);

    // Casos muy específicos donde sabemos que el resultado es racional
    const knownRationalResults = [
        // División de iguales = 1
        { pattern: /^π\/π$/, result: 1 },
        { pattern: /^pi\/pi$/, result: 1 },
        { pattern: /^e\/e$/, result: 1 },
        { pattern: /^φ\/φ$/, result: 1 },
        { pattern: /^phi\/phi$/, result: 1 },
        { pattern: /^τ\/τ$/, result: 1 },
        { pattern: /^tau\/tau$/, result: 1 },
        { pattern: /^√2\/√2$/, result: 1 },
        { pattern: /^√3\/√3$/, result: 1 },
        { pattern: /^√5\/√5$/, result: 1 },

        // Resta de iguales = 0
        { pattern: /^π-π$/, result: 0 },
        { pattern: /^pi-pi$/, result: 0 },
        { pattern: /^e-e$/, result: 0 },

        // Casos especiales conocidos
        { pattern: /^2\*π\/τ$/, result: 1 },
        { pattern: /^τ\/2\*π$/, result: 1 },
    ];

    // Verificar casos conocidos que resultan en números racionales
    for (const knownCase of knownRationalResults) {
        if (knownCase.pattern.test(normalizedExpr)) {
            if (Math.abs(result - knownCase.result) < 0.0001) {
                if (knownCase.result > 0 && Number.isInteger(knownCase.result)) {
                    return 'naturals';
                }
                if (Number.isInteger(knownCase.result)) {
                    return 'integers';
                }
                return 'rationals';
            }
        }
    }

    // Casos especiales donde el resultado es racional/entero a pesar de involucrar irracionales
    const specialRationalCases = [
        // Casos que resultan en 1
        /π\/π/, /pi\/pi/, /e\/e/, /φ\/φ/, /phi\/phi/, /τ\/τ/, /tau\/tau/,
        /√2\/√2/, /√3\/√3/, /√5\/√5/,

        // Casos que resultan en números racionales conocidos
        /π\/-π/, /pi\/-pi/, /e\/-e/, /φ\/-φ/, /phi\/-phi/,
        /-π\/π/, /-pi\/pi/, /-e\/e/, /-φ\/φ/, /-phi\/phi/,

        // Casos como e/2e = 0.5 (necesitamos ser más específicos)
        /e\/2\*e/, /π\/2\*π/, /pi\/2\*pi/
    ];

    // Verificar casos especiales que dan resultados racionales
    for (const pattern of specialRationalCases) {
        if (pattern.test(expression.replace(/\s/g, ''))) {
            // Si el resultado es un entero positivo, es natural
            if (result > 0 && Number.isInteger(result)) {
                return 'naturals';
            }
            // Si es entero, es entero
            if (Number.isInteger(result)) {
                return 'integers';
            }
            // Si no, es racional
            return 'rationals';
        }
    }

    // Lista de símbolos irracionales para detectar en expresiones
    const irrationalSymbols = ['π', 'pi', 'e', 'φ', 'phi', 'τ', 'tau', 'ln2', 'ln10', '√', 'sqrt'];

    // Verificar si la expresión contiene números irracionales
    const containsIrrationals = irrationalSymbols.some(symbol => expression.includes(symbol));

    if (containsIrrationals) {
        // Casos especiales donde suma/resta de irracionales puede dar resultado racional
        const rationalResultPatterns = [
            // Casos como π + (-π) = 0, e - e = 0
            /π\+\(-π\)/, /pi\+\(-pi\)/, /e\+\(-e\)/, /φ\+\(-φ\)/, /phi\+\(-phi\)/,
            /π-π/, /pi-pi/, /e-e/, /φ-φ/, /phi-phi/, /τ-τ/, /tau-tau/,
            /√2-√2/, /√3-√3/, /√5-√5/,

            // Otros casos especiales conocidos
            /2\*π\/τ/, /2\*pi\/tau/, /τ\/2\*π/, /tau\/2\*pi/
        ];

        // Verificar si es un caso especial que da resultado racional
        const isSpecialRational = rationalResultPatterns.some(pattern =>
            pattern.test(expression.replace(/\s/g, ''))
        );

        if (isSpecialRational) {
            if (result > 0 && Number.isInteger(result)) {
                return 'naturals';
            }
            if (Number.isInteger(result)) {
                return 'integers';
            }
            return 'rationals';
        }

        // Si contiene irracionales y no es un caso especial, probablemente es irracional
        return 'irrationals';
    }

    // Si no contiene irracionales, clasificar normalmente por el resultado
    if (result > 0 && Number.isInteger(result)) {
        return 'naturals';
    }
    if (Number.isInteger(result)) {
        return 'integers';
    }
    return 'rationals';
}

/**
 * Clasifica un número según su tipo matemático
 * @param {number} num - El valor numérico a clasificar
 * @param {string} originalInput - La expresión original ingresada
 * @returns {string} - El tipo de número ('naturals', 'integers', 'rationals', 'irrationals')
 */
function classifyNumber(num, originalInput) {
    // Verificar si es un número natural (entero positivo)
    if (num > 0 && Number.isInteger(num)) {
        return 'naturals';
    }
    
    // Verificar si es un número entero
    if (Number.isInteger(num)) {
        return 'integers';
    }
    
    // Lista de constantes irracionales conocidas
    const irrationalConstants = [
        'π', 'pi', 'e', 'φ', 'phi', 'τ', 'tau', 'ln2', 'ln10', 
        '√2', '√3', '√5', '√7', '√8', '√10', '√11', '√12', '√13', '√15', '√17', '√19', '√20',
        '-√2', '-√3', '-√5'
    ];
    
    // Si es una constante irracional directa
    if (irrationalConstants.includes(originalInput)) {
        return 'irrationals';
    }
    
    // Verificar si contiene sqrt() y clasificar según el contenido
    if (originalInput.includes('sqrt(')) {
        const sqrtMatch = originalInput.match(/sqrt\(([^)]+)\)/);
        if (sqrtMatch) {
            const innerExpression = sqrtMatch[1];
            let innerValue;
            
            try {
                // Evaluar lo que está dentro del sqrt()
                if (innerExpression.includes('/') && !innerExpression.includes('*') && 
                    !innerExpression.includes('+') && !innerExpression.includes('-', 1)) {
                    // Fracción simple
                    const parts = innerExpression.split('/');
                    if (parts.length === 2) {
                        const num = parseFloat(parts[0]);
                        const den = parseFloat(parts[1]);
                        if (!isNaN(num) && !isNaN(den) && den !== 0) {
                            innerValue = num / den;
                        }
                    }
                } else {
                    // Expresión o número simple
                    const safeChars = /^[0-9+\-*/.() ]+$/;
                    if (safeChars.test(innerExpression)) {
                        innerValue = Function('"use strict"; return (' + innerExpression + ')')();
                    } else {
                        innerValue = parseFloat(innerExpression);
                    }
                }
                
                if (!isNaN(innerValue) && innerValue >= 0) {
                    const sqrtResult = Math.sqrt(innerValue);
                    
                    // Verificar si es un cuadrado perfecto
                    const isInteger = Number.isInteger(sqrtResult);
                    
                    if (isInteger) {
                        // Es cuadrado perfecto
                        if (sqrtResult > 0) {
                            return 'naturals';
                        } else if (sqrtResult === 0) {
                            return 'integers';
                        }
                    } else {
                        // No es cuadrado perfecto, es irracional
                        return 'irrationals';
                    }
                }
            } catch (e) {
                // Si hay error en la evaluación, asumir que es irracional
                return 'irrationals';
            }
        }
    }
    
    // Analizar expresiones con operaciones matemáticas
    if (originalInput.includes('*') || originalInput.includes('+') || 
        originalInput.includes('-') || originalInput.includes('/')) {
        return classifyExpression(originalInput, num);
    }
    
    // Verificar si es una fracción simple (racional)
    if (originalInput.includes('/')) {
        return 'rationals';
    }
    
    // Si es decimal, asumimos que es racional a menos que se especifique lo contrario
    return 'rationals';
}

/**
 * Obtiene el nombre completo de la clasificación matemática
 * @param {string} classification - El tipo de clasificación
 * @returns {string} - El nombre completo con símbolo matemático
 */
function getClassificationName(classification) {
    const names = {
        'naturals': 'ℕ (Naturales)',
        'integers': 'ℤ (Enteros)', 
        'rationals': 'ℚ (Racionales)',
        'irrationals': 'ℝ-ℚ (Irracionales)'
    };
    return names[classification] || 'No clasificado';
}

// ========== FUNCIONES DE INTERFAZ DE USUARIO ==========

/**
 * Agrega un número desde el input principal
 * Valida el formato, rango y duplicados antes de agregar
 */
function addNumber() {
    const input = document.getElementById('numberInput').value;
    
    if (!input) {
        alert('Por favor ingresa un número');
        return;
    }
    
    const value = parseNumber(input);
    if (value === null) {
        alert('Formato de número no válido. Ejemplos válidos: sqrt(7), 2*π, 1/e, √2, -1/2');
        return;
    }
    
    if (Math.abs(value) > currentRange) {
        alert(`El número está fuera del rango actual (-${currentRange} a ${currentRange}). Cambia el rango de visualización.`);
        return;
    }
    
    // Verificar si el punto ya existe (con tolerancia para errores de punto flotante)
    const existingPoint = points.find(p => Math.abs(p.value - value) < 0.0001);
    if (existingPoint) {
        alert('Este número ya está en la recta numérica');
        return;
    }
    
    // Clasificar el número y agregarlo al array
    const classification = classifyNumber(value, input);
    
    points.push({
        value: value,
        originalInput: input,
        classification: classification
    });
    
    // Limpiar el input y actualizar la visualización
    document.getElementById('numberInput').value = '';
    updateDisplay();
}

/**
 * Agrega un número predefinido desde los botones
 * @param {string} input - La expresión del número predefinido
 */
function addPresetNumber(input) {
    const value = parseNumber(input);
    
    if (value === null || Math.abs(value) > currentRange) {
        alert(`El número ${input} está fuera del rango actual`);
        return;
    }
    
    // Verificar si el punto ya existe
    const existingPoint = points.find(p => Math.abs(p.value - value) < 0.0001);
    if (existingPoint) {
        alert('Este número ya está en la recta numérica');
        return;
    }
    
    // Clasificar el número y agregarlo
    const classification = classifyNumber(value, input);
    
    points.push({
        value: value,
        originalInput: input,
        classification: classification
    });
    
    // Actualizar la visualización
    updateDisplay();
}

/**
 * Elimina todos los puntos de la recta numérica
 */
function clearAll() {
    points = [];
    updateDisplay();
}

/**
 * Actualiza toda la visualización (recta, lista y selectores)
 */
function updateDisplay() {
    drawNumberLine();
    updatePointsList();
    updateDistanceSelectors();
}

// ========== FUNCIONES DE VISUALIZACIÓN ==========

/**
 * Dibuja la recta numérica con todas las marcas y puntos
 */
function drawNumberLine() {
    const numberLine = document.getElementById('numberLine');
    numberLine.innerHTML = '';
    
    // Crear la línea base de la recta
    const line = document.createElement('div');
    line.className = 'line';
    numberLine.appendChild(line);
    
    // Crear marcas de graduación
    const tickCount = currentRange * 2 + 1; // De -range a +range
    for (let i = 0; i < tickCount; i++) {
        const value = -currentRange + i;
        const percentage = (i / (tickCount - 1)) * 90 + 5; // 5% de margen a cada lado
        
        // Crear la marca vertical
        const tick = document.createElement('div');
        tick.className = 'tick';
        tick.style.left = percentage + '%';
        numberLine.appendChild(tick);
        
        // Crear la etiqueta numérica
        const label = document.createElement('div');
        label.className = 'tick-label';
        label.style.left = percentage + '%';
        label.textContent = value;
        numberLine.appendChild(label);
    }
    
    // Agregar los puntos de números agregados
    points.forEach((point, index) => {
        const percentage = ((point.value + currentRange) / (2 * currentRange)) * 90 + 5;
        
        // Crear el elemento visual del punto
        const pointElement = document.createElement('div');
        pointElement.className = `number-point ${point.classification}`;
        pointElement.style.left = percentage + '%';
        pointElement.draggable = false;
        
        // Crear la etiqueta del punto
        const pointLabel = document.createElement('div');
        pointLabel.className = 'point-label';
        pointLabel.textContent = `${point.originalInput} ≈ ${point.value.toFixed(3)}`;
        pointElement.appendChild(pointLabel);
        
        // Agregar evento de clic para eliminar
        pointElement.onclick = () => removePoint(index);
        pointElement.title = `${point.originalInput} (${getClassificationName(point.classification)})\nHaz clic para eliminar`;
        
        numberLine.appendChild(pointElement);
    });
}

/**
 * Elimina un punto específico de la recta
 * @param {number} index - El índice del punto a eliminar
 */
function removePoint(index) {
    if (confirm('¿Deseas eliminar este punto?')) {
        points.splice(index, 1);
        updateDisplay();
    }
}

/**
 * Actualiza la lista de puntos ordenada por valor
 */
function updatePointsList() {
    const pointsList = document.getElementById('pointsList');
    
    // Si no hay puntos, mostrar mensaje informativo
    if (points.length === 0) {
        pointsList.innerHTML = '<p style="color: #6c757d; font-style: italic;">Agrega números para ver su clasificación aquí</p>';
        return;
    }
    
    // Ordenar puntos por valor de menor a mayor
    const sortedPoints = [...points].sort((a, b) => a.value - b.value);
    
    // Generar HTML para cada punto
    pointsList.innerHTML = sortedPoints.map(point => `
        <div class="point-item" style="border-left-color: ${getClassificationColor(point.classification)}">
            <div>
                <strong>${point.originalInput}</strong> ≈ ${point.value.toFixed(6)}
                <br>
                <small>${getClassificationName(point.classification)}</small>
            </div>
            <div style="text-align: right;">
                <small>Posición: ${point.value.toFixed(3)}</small>
            </div>
        </div>
    `).join('');
}

/**
 * Obtiene el color asociado a cada tipo de número
 * @param {string} classification - El tipo de clasificación
 * @returns {string} - El código de color hexadecimal
 */
function getClassificationColor(classification) {
    const colors = {
        'naturals': '#e74c3c',
        'integers': '#f39c12',
        'rationals': '#27ae60',
        'irrationals': '#8e44ad'
    };
    return colors[classification] || '#3498db';
}

// ========== CALCULADORA DE DISTANCIAS ==========

/**
 * Actualiza los selectores de la calculadora de distancias
 */
function updateDistanceSelectors() {
    const pointAItems = document.getElementById('pointA-items');
    const pointBItems = document.getElementById('pointB-items');
    const pointASelected = document.getElementById('pointA-selected');
    const pointBSelected = document.getElementById('pointB-selected');
    
    // Limpiar las opciones existentes
    pointAItems.innerHTML = '<div data-value="">Selecciona un punto</div>';
    pointBItems.innerHTML = '<div data-value="">Selecciona un punto</div>';
    
    // Resetear el texto seleccionado si no hay puntos
    if (points.length === 0) {
        pointASelected.textContent = 'Selecciona un punto';
        pointBSelected.textContent = 'Selecciona un punto';
        document.getElementById('pointA-container').setAttribute('data-value', '');
        document.getElementById('pointB-container').setAttribute('data-value', '');
        return;
    }
    
    // Agregar cada punto como opción en ambos selectores
    points.forEach((point, index) => {
        const optionText = `${point.originalInput} (${point.value.toFixed(3)})`;
        
        // Crear opción para el selector A
        const optionA = document.createElement('div');
        optionA.setAttribute('data-value', index);
        optionA.textContent = optionText;
        pointAItems.appendChild(optionA);
        
        // Crear opción para el selector B
        const optionB = document.createElement('div');
        optionB.setAttribute('data-value', index);
        optionB.textContent = optionText;
        pointBItems.appendChild(optionB);
    });
}

/**
 * Calcula la distancia entre dos puntos seleccionados
 */
function calculateDistance() {
    const pointAValue = document.getElementById('pointA-container').getAttribute('data-value');
    const pointBValue = document.getElementById('pointB-container').getAttribute('data-value');
    const resultDiv = document.getElementById('distanceResult');

    // Verificar que ambos puntos estén seleccionados
    if (!pointAValue || !pointBValue) {
        resultDiv.innerHTML = '<div style="color: #dc3545;">Selecciona ambos puntos para calcular la distancia</div>';
        return;
    }

    // Verificar que los puntos sean diferentes
    if (pointAValue === pointBValue) {
        resultDiv.innerHTML = '<div style="color: #dc3545;">Selecciona dos puntos diferentes</div>';
        return;
    }

    // Obtener los puntos seleccionados
    const pointA = points[parseInt(pointAValue)];
    const pointB = points[parseInt(pointBValue)];
    
    // Calcular la distancia como valor absoluto de la diferencia
    const distance = Math.abs(pointA.value - pointB.value);

    // Mostrar el resultado formateado
    resultDiv.innerHTML = `
        <div class="distance-result">
            <strong>Distancia entre ${pointA.originalInput} y ${pointB.originalInput}:</strong><br>
            |${pointA.value.toFixed(3)} - ${pointB.value.toFixed(3)}| = ${distance.toFixed(6)} unidades
        </div>
    `;
}

// ========== SELECTORES PERSONALIZADOS ==========

/**
 * Inicializa los selectores personalizados para la calculadora de distancias
 */
function initCustomSelects() {
    ['pointA', 'pointB'].forEach(selectId => {
        const container = document.getElementById(selectId + '-container');
        const selected = document.getElementById(selectId + '-selected');
        const items = document.getElementById(selectId + '-items');

        // Manejar clic en el selector principal
        selected.addEventListener('click', function(e) {
            e.stopPropagation();

            // Cerrar otros dropdowns primero
            document.querySelectorAll('.select-items').forEach(otherItems => {
                if (otherItems !== items) {
                    otherItems.classList.remove('show');
                }
            });
            document.querySelectorAll('.select-selected').forEach(otherSelected => {
                if (otherSelected !== selected) {
                    otherSelected.classList.remove('select-arrow-active');
                }
            });

            // Alternar el estado del dropdown actual
            const isCurrentlyOpen = items.classList.contains('show');
            if (isCurrentlyOpen) {
                items.classList.remove('show');
                selected.classList.remove('select-arrow-active');
                adjustZIndex(null); // Resetear z-index
            } else {
                items.classList.add('show');
                selected.classList.add('select-arrow-active');
                adjustZIndex(selectId); // Aumentar z-index para el selector activo
            }
        });

        // Manejar clics en las opciones del dropdown
        items.addEventListener('click', function(e) {
            e.stopPropagation();
            if (e.target.hasAttribute('data-value')) {
                // Actualizar el texto mostrado
                selected.textContent = e.target.textContent;
                container.setAttribute('data-value', e.target.getAttribute('data-value'));

                // Remover clase 'selected' de todas las opciones
                items.querySelectorAll('.selected').forEach(item => item.classList.remove('selected'));

                // Agregar clase 'selected' a la opción clickeada
                e.target.classList.add('selected');

                // Cerrar el dropdown
                items.classList.remove('show');
                selected.classList.remove('select-arrow-active');
                adjustZIndex(null); // Resetear z-index
            }
        });
    });
}

/**
 * Cierra todos los selectores personalizados abiertos
 */
function closeAllSelect() {
    document.querySelectorAll('.select-items').forEach(items => {
        items.classList.remove('show');
    });
    document.querySelectorAll('.select-selected').forEach(selected => {
        selected.classList.remove('select-arrow-active');
    });
}

/**
 * Ajusta los z-index para evitar problemas de superposición en los dropdowns
 * @param {string|null} activeSelectId - ID del selector activo o null para resetear
 */
function adjustZIndex(activeSelectId) {
    // Resetear todos los z-indexes a valores base
    document.querySelectorAll('.distance-field').forEach(field => {
        field.style.zIndex = '100';
    });
    document.querySelectorAll('.distance-field .custom-select').forEach(select => {
        select.style.zIndex = '101';
    });
    document.querySelectorAll('.distance-field .select-items').forEach(items => {
        items.style.zIndex = '1000';
    });

    // Aumentar el z-index del selector activo
    if (activeSelectId) {
        const activeField = document.getElementById(activeSelectId + '-container').closest('.distance-field');
        const activeSelect = document.getElementById(activeSelectId + '-container');
        const activeItems = document.getElementById(activeSelectId + '-items');

        if (activeField) activeField.style.zIndex = '2000';
        if (activeSelect) activeSelect.style.zIndex = '2001';
        if (activeItems) activeItems.style.zIndex = '12000';
    }
}

// ========== INICIALIZACIÓN Y EVENT LISTENERS ==========

/**
 * Event listener para detectar Enter en el input de números
 */
document.getElementById('numberInput').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        addNumber();
    }
});

/**
 * Event listener para cerrar dropdowns al hacer clic fuera de ellos
 */
document.addEventListener('click', function(e) {
    if (!e.target.closest('.custom-select')) {
        closeAllSelect();
        adjustZIndex(null); // Resetear z-index
    }
});

// ========== INICIALIZACIÓN DE LA APLICACIÓN ==========

// Inicializar los selectores personalizados
initCustomSelects();

// Mostrar la visualización inicial
updateDisplay();
 
</script> 
</body> 
</html> 
